{
open FSharp.Text.Lexing
open Stroodel.Util

let text (lexbuf: LexBuffer<_>) =
  LexBuffer<_>.LexemeString lexbuf

let int (lexbuf: LexBuffer<_>) =
  let s = LexBuffer<_>.LexemeString lexbuf
  int s

let dummyInfo = Error.Info.UNKNOWN

let info (lexbuf: LexBuffer<_>) =
  let f = "" // TODO: use lexbuf.StartPos.FileName ! 
  let l = lexbuf.StartPos.Line
  let c = lexbuf.StartPos.AbsoluteOffset // TODO: is this the offset in the line or from the very start?
  Error.Info.FI(f, l, c)

let printError (i: Error.Info) =
  match i with
  | Error.Info.UNKNOWN -> "ParseError at unknown position!"
  | Error.Info.FI(_, l, c) -> "ParseError at line " + (string l) + " , offset " + (string c)

let newline (lexbuf: LexBuffer<_>) =
  lexbuf.StartPos <- lexbuf.StartPos.NextLine

let keywordsAndSymbols : Map<string,(Error.Info -> Parser.token)> =
  [("the", fun i -> Parser.THE i);
    ("Atom", fun i -> Parser.ATOM i);
    ("Pair", fun i -> Parser.PAIR i);
    ("List", fun i -> Parser.LIST i);
    ("Nat", fun i -> Parser.NAT i);
    ("nil", fun i -> Parser.NIL i);
    ("cons", fun i -> Parser.CONS i);
    ("same", fun i -> Parser.SAME i);
    ("sole", fun i -> Parser.SOLE i);
    ("zero", fun i -> Parser.ZERO i);
    ("λ", fun i -> Parser.LAMBDA i);
    ("lambda", fun i -> Parser.LAMBDA i)]
  |> Map.ofList

// Looks up the build function from our hash table
// or creates an arbitrary ID:
let createId i s =
  match Map.tryFind s keywordsAndSymbols with
  | Some f -> f i
  | None -> Parser.ID s
}

// auxiliary tokens:
let char        = ['a'-'z' 'A'-'Z']
let digit       = ['0'-'9']
let whitespace  = [' ' '\t' ]
let newline     = ('\n' | '\r' '\n')
let arrow       = '→'
let bigpi       = 'Π'
let bigsigma    = 'Σ'
let lambda      = 'λ'
let universe    = 'U'

// tokenizer rules:
rule tokenstream = parse
| char+ ('-' char+)*    { createId (info lexbuf) (text lexbuf) }
| digit+                { Parser.INTV (int lexbuf) }
| "'"                   { Parser.TICK (info lexbuf) }
| "("                  { Parser.LPAREN (info lexbuf) }
| ")"                  { Parser.RPAREN (info lexbuf) }
| whitespace            { tokenstream lexbuf }
//| newline { newline lexbuf; tokenstream lexbuf }
| eof                   { Parser.EOF (info lexbuf) }
| _                     { failwith (printError (info lexbuf)) }
